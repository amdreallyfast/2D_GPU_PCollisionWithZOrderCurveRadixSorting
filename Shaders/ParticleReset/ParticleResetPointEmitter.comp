// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES Random.comp
// REQUIRES NewVelocityBetweenMinAndMax.comp
// REQUIRES QuickNormalize.comp
// REQUIRES LinearBlend.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;

// unlike SSBOs, atomic counter buffers seem to need a declaration like this and cannot be bound 
// dynamically as in ParticleSsbo and PolygonSsbo, so declare the atomic counters up front to 
// make it easier to keep the numbers straight.
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = ATOMIC_COUNTER_BUFFER_BINDING, offset = 0) uniform atomic_uint acResetParticleCounter;


/*------------------------------------------------------------------------------------------------
Description:
    Resets a particle to a point emitter's position plus a variation on the position that gives
    the particles the appearance of eminating from a cloud (looks nicer than eminating from a
    point).
Parameters:
    pCopy   GLSL doesn't do references, so values are passed by copy in GPU shared memory (fast 
            memory).  Change this and return the result.
Returns:
    A Particle object with a random 2D velocity and a position that is the point emitter's 
    position plus a small variation on that position to give the appearance of spawning in a 
    particle cloud.
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
uniform vec4 uPointEmitterCenter;
Particle PointEmitterResetPos(Particle pCopy)
{
    // generate a new position
    // Note: Use last position as the rand seed for X, then swizzle a bit for the Y.
    float posX = RandomOnRangeNeg1ToPos1(pCopy._pos.xy);
    float posY = RandomOnRangeNeg1ToPos1(pCopy._pox.yx);

    // make the particle appear in a cloud around the point emitter's center
    // Note: Do this by normalizing the particle's new position so that it ends up on the rim of 
    // a circle with a radius of exactly 1 unit (don't have "in" or "cm" or whatever in window 
    // space, so just say "unit").  I don't want the particle to be spawning only on a circle 
    // though that takes up all of window space (X and Y on the range [-1,+1]), so multiply this 
    // new location by a small fraction of 1 to put the new position on the rim of a smaller 
    // circle.  This circle shall be a region around the point emitter from which the particle 
    // shall eminate.  Then do a linear blend between the new position on the rim of this circle 
    // and the particle emitter's center.  This shall be the particle's new span position.
    vec4 outerPosLimit = (0.1 * QuickNormalize(vec4(posX, posY, 0.0, 0.0)))
    vec4 posVariance = LinearBlend(uPointEmitterCenter, outerPosLimit, RandomOnRange0To1(vec(posX, posY)));
    pCopy._pos = uPointEmitterCenter + posVariance;
    
    // velocity
    // Note: Similar to position, use the last know velocity as the rand seed for X, then 
    // swizzle for the Y.
    float velX = RandomOnRangeNeg1ToPos1(pCopy._vel.xy);
    float velY = RandomOnRangeNeg1ToPos1(pCopy._vel.yx);
    vec4 randomVelocityVector = QuickNormalize(vec4(velX, velY, 0.0, 0.0));
    pCopy._vel = randomVelocityVector * NewVelocityBetweenMinAndMax(vec2(velX, velY));
    
    return pCopy;
}


// this value is used to prevent uParticleBufferSize particles from being emitted all at once
// Note: This is particularly helpful when the particles are spread out on multiple emitters.
uniform uint uMaxParticleEmitCount;

/*------------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator:    John Cox, 4/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uParticleBufferSize)
    {
        Particle p = AllParticles[index];

        if (p._isActive == 0)
        {
            // only reactivate the particle if there is enough left in the particle limit for 
            // this update
            if (atomicCounterIncrement(acResetParticleCounter) < uMaxParticleEmitCount)
            {
                p = PointEmitterResetPos(p);
                p._isActive = 1;
            }

            // copy the updated one back into the array
            AllParticles[index] = p;
        }
        else
        {
            // particle active, so don't reset it; just return;
        }
    }
}

