// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
// REQUIRES IntermediateSortBuffers.comp
// REQUIRES PositionToMortonCode.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARALLEL_SORT_WORK_GROUP_SIZE_X) in;



// TODO: ??is morton code calculation required for anything else? could it be isolated to this compute shader??



/*------------------------------------------------------------------------------------------------
Description:
    If the particle is inactive, then it is given a dummy Morton code of maximum uint so that it 
    will be sorted to the back of the particle collection.  If active, then a Morton Code is 
    calculated for it from the particle's position.
Parameters: None
Returns:    None
Creator:    John Cox, 3/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    // all particles that are being sorted must be in the first half of the buffer
    // Note: This is guaranteed by the ParallelSort shader controller.  It sorts over an even 
    // number of bits, so the final sorted particles always end up in the first half of the buffer. 
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex > uNumberParticles)
    {
        return;
    }

    // assume inactive and set a value that will put it at the back of the sort
    uint mortonCode = 0xffffffff;
    if (AllParticles[threadIndex]._isActive == 1)
    {
        // calculate Morton Code based on position
        PrimitiveVec4 pos = AllParticles[threadIndex]._pos;
        mortonCode = PositionToMortonCode(vec4(pos.x, pos.y, pos.z, pos.w));
    }

    AllParticles[threadIndex]._mortonCode = mortonCode;
}
