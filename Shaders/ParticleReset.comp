// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;

// unlike SSBOs, atomic counter buffers seem to need a declaration like this and cannot be bound 
// dynamically as in ParticleSsbo and PolygonSsbo, so declare the atomic counters up front to 
// make it easier to keep the numbers straight.
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = ACTIVE_PARTICLE_ATOMIC_COUNTER_BUFFER, offset = 0) uniform atomic_uint acResetParticleCounter;



/*------------------------------------------------------------------------------------------------
Description:
    A convenience function whose name indicates its purpose.  Also useful so that I don't have 
    to type the actual vector name three times.  This isn't quite as accurate as a real square 
    root, but from what I've read, it is pretty accurate out to a few decimal places, so it's 
    good enough for simulation work.
Parameters:
    v   The vec4 to be normalized.
Returns:
    A normalized copy of input v;
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
vec4 QuickNormalize(vec4 v)
{
    return inversesqrt(dot(v, v)) * v;
}

/*------------------------------------------------------------------------------------------------
Description:
    Helps to generate a random displacement region around a particle's spawn point.  It gives 
    the illusion that the particles come from a cloud instead of a point.  It's a "looks nice" 
    feature.
Parameters:
    v1              The start of the linear blend.
    v2              The end of the linear blend.
    Between0And1    Some fraction of the difference between v1 and v2.
Returns:
    A vec4 that is linearly blended according to Between0and1.
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
vec4 LinearMix(vec4 v1, vec4 v2, float Between0And1)
{
    return (v1 * (1 - Between0And1)) + (v2 * Between0And1);
}

/*------------------------------------------------------------------------------------------------
Description:
    Generate a semi-random number on the range [0,+1] (I think; I don't know if it actually hits 
    0 or +1).  Found online:
    http://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner

    Like rand() on the CPU side, this is a chaotic hash function whose output is only as random 
    as the input.  Calling it multiple times with the same input will always generate the same 
    output.  But unlike rand(), this function does not have access to OS-level calls to the 
    CPU's clock counter, nor is there access to any of the GPU's clock counters, so inputs must 
    be provided by the user.

    I changed the source function to use atomic counter instead of taking a vec2 so that I 
    wouldn't have to rely on initial values being provided by the CPU side of the program.  This 
    way I can initialize the particle buffer with default values and get rid of some code.

    Note: This random hash has its limits.  When provided two sequential integers from the 
    atomic counter, there is a little bit of banding in the bar emitters, but the point emitters 
    look good enough, so I can live with this.  I don't need encryption-level randomness for a 
    particle simulation.
Parameters: None
Returns:
    A semi-random float.
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
float RandomOnRange0To1()
{
    // TODO: take a vec2; resetting a particle needs several random numbers though, so it needs several seeds
    // bar emitter reset position
    //  RandomOnRange0To1 for distance along the bar (pass in pos.xy)
    //  NewVelocityBetweenMinAndMax()
    //      RandomOnRange0To1 for variation on velocity range (pass in vel.xy)
    // point emitter reset position to cloud
    //  pos x = RandomOnRangeNeg1ToPos1 (pass in pos.xy)
    //  pos y = RandomOnRangeNeg1ToPos1 (pass in pos.yx)
    //  linear mix 
    //  vel x = RandomOnRangeNeg1ToPos1 (pass in vel.xy)
    //  vel y = RandomOnRangeNeg1ToPos1 (pass in vel.yx)
//highp float rand(vec2 co)
//{
//    highp float a = 12.9898;
//    highp float b = 78.233;
//    highp float c = 43758.5453;
//    highp float dt= dot(co.xy ,vec2(a,b));
//    highp float sn= mod(dt,3.14);
//    return fract(sin(sn) * c);
//}

    // increment the rand seed counter, but NOT the particle counter (that is for main())
    // Note: Using two atomic counters because it was discovered by experience that passing in 
    // two sequential values wasn't random enough for personal taste.  There was some banding 
    // that was observed in the bar emitters, and using two counters that are likely to have 
    // very different values seems to have fixed the problem.
    // Also Note: There is still some banding.  I don't know how to get rid of it.
    float val1 = atomicCounterIncrement(acRandSeed);
    float val2 = atomicCounter(acResetParticleCounter);
    return fract(sin(dot(vec2(val1, val2) ,vec2(12.9898,78.233))) * 43758.5453);
}

/*------------------------------------------------------------------------------------------------
Description:
    A convenience function that generates a single number on the range [-1,+1] (again, I don't 
    know if it actually hits -1 or +1 exactly).  It is used to generate random X and Y velocity 
    vectors for newly-eminating particles.  
Parameters:    None
Returns:
    A semi-random float on the range [-1,+1].
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
float RandomOnRangeNeg1ToPos1()
{
    // TODO: move to a Random.comp composite shader


    // TODO: 
    // - take vec2 argument
    // - use the same random number for <0.5 check and for value
    if (RandomOnRange0To1() < 0.5)
    {
        return -1.0 * RandomOnRange0To1();
    }
    else
    {
        return +1.0 * RandomOnRange0To1();
    }
}

/*------------------------------------------------------------------------------------------------
Description:
    Similar to the MinMaxVelocity::GetNew() on the CPU side, this function calculates a random 
    velocity between a min and max value.  The min value is provided by a uniform, but the max 
    is instead inferred by the "delta particle velocity" uniform since all that is needed for 
    the calculation is a variance on the delta.

    Used for both point and bar emitters.
Parameters:    None
Returns:
    A semi-random float on the range uMinParticleVelocity + (rand0To1 * uDeltaParticleVelocity).
Creator:    John Cox (10-10-2016)
------------------------------------------------------------------------------------------------*/
uniform float uMinParticleVelocity;
uniform float uDeltaParticleVelocity;
float NewVelocityBetweenMinAndMax()
{
    float velocityVariation = RandomOnRange0To1() * uDeltaParticleVelocity;
    float velocityMagnitude = uMinParticleVelocity + velocityVariation;

    return velocityMagnitude;
}

/*------------------------------------------------------------------------------------------------
Description:
    Resets a particle to a point emitter's position plus a variation on the position that gives
    the particles the appearance of eminating from a cloud (looks nicer than eminating from a
    point).
Parameters:
    p   A Particle instance.  
Returns:
    A Particle object with a random 2D velocity and a position that is the point emitter's 
    position plus a small variation on that position to give the appearance of spawning in a 
    particle cloud.
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
uniform vec4 uPointEmitterCenter;
Particle PointEmitterResetPos(Particle p)
{
    // TODO: move to ParticleResetPointEmitter

    Particle pCopy = p;
    
    vec4 basePosition = uPointEmitterCenter;
    float posX = RandomOnRangeNeg1ToPos1();
    float posY = RandomOnRangeNeg1ToPos1();

    // need to normalize the outer limit (), but to do that we can't have a 1 in the w position 
    // or else the X and Y's normalization get's messed up
    // Note: To make the particle appear in a cloud around the point emitter's center, need 
    // Note: Window space is on the range [-1,+1] on X and Y, hence the normalizing.
    vec4 outerPosLimit = 0.1 * QuickNormalize(vec4(posX, posY, 0.0, 0.0));
    vec4 posVariance = LinearMix(uPointEmitterCenter, outerPosLimit, RandomOnRange0To1());
    pCopy._pos = basePosition + posVariance;
    
    // velocity
    float velX = RandomOnRangeNeg1ToPos1();
    float velY = RandomOnRangeNeg1ToPos1();
    vec4 randomVelocityVector = QuickNormalize(vec4(velX, velY, 0.0, 0.0));
    pCopy._vel = randomVelocityVector * NewVelocityBetweenMinAndMax();
    
    return pCopy;
}

/*------------------------------------------------------------------------------------------------
Description:
    Like PointEmitterResetPos(...), but for a bar emitter.
Parameters:
    p   A Particle instance.  
Returns:
    A Particle object with a 2D velocity on the range min + (rand * delta) and a position 
    randomly placed between the bar emitter's start and end points.
Creator:    John Cox (10-10-2016)
------------------------------------------------------------------------------------------------*/
uniform vec4 uBarEmitterP1;
uniform vec4 uBarEmitterP2;
uniform vec4 uBarEmitterEmitDir;
Particle BarEmitterResetPos(Particle p)
{
    // TODO: move to ParticleResetBarEmitter.comp

    Particle pCopy = p;

    // position
    vec4 start = uBarEmitterP1;
    vec4 end = uBarEmitterP2;
    vec4 startToEnd = end - start;
    pCopy._pos = start + (RandomOnRange0To1() * startToEnd);

    // velocity
    vec4 velocityDir = QuickNormalize(uBarEmitterEmitDir);
    pCopy._vel = velocityDir * NewVelocityBetweenMinAndMax();

    return pCopy;
}

uniform uint uUsePointEmitter;

// this value is used to prevent uMaxParticles particles from being emitted all at once
// Note: This is used when the particles are spread out on multiple emitters.
uniform uint uMaxParticleEmitCount;

/*------------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uMaxParticles)
    {
        Particle p = AllParticles[index];

        if (p._isActive == 0)
        {
            // only reactivate the particle if there is enough left in the particle limit for 
            // this update
            if (atomicCounterIncrement(acResetParticleCounter) < uMaxParticleEmitCount)
            {
                if (uUsePointEmitter == 1)
                {
                    // use the point emitter with whatever point was uploaded
                    p = PointEmitterResetPos(p);
                }
                else
                {
                    // use bar emitter
                    p = BarEmitterResetPos(p);
                }
                
                p._isActive = 1;
            }

            // copy the updated one back into the array
            AllParticles[index] = p;
        }
        else
        {
            // particle active, so don't reset it
        }
    }
}

