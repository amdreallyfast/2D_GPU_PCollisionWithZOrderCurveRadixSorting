// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;


// unlike SSBOs, atomic counter buffers seem to need a declaration like this and cannot be bound 
// dynamically as in ParticleSsbo and PolygonSsbo, so declare the atomic counters up front to 
// make it easier to keep the numbers straight.
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = PARTICLE_UPDATE_ATOMIC_COUNTER_BUFFER_BINDING, offset = 0) uniform atomic_uint acActiveParticleCounter;


/*------------------------------------------------------------------------------------------------
Description:
    Checks if the provided particle has gone outside the circle that defines where particles are 
    "active".
Parameters:
    particleIndex   An index into the AllParticles array.
Returns:
    True if the particle is out of bounds and should be reset, otherwise false.
Creator:    John Cox (1-7-2016)
------------------------------------------------------------------------------------------------*/
uniform vec4 uParticleRegionCenter;
uniform float uParticleRegionRadiusSqr;
//bool ParticleOutOfBoundsPolygon(vec4 particleIndex)
//{
//    vec4 regionCenterToParticle = AllParticles[particleIndex]._pos - uParticleRegionCenter;
//
//    //float x = regionCenterToParticle.x;
//    //float y = regionCenterToParticle.y;
//    //float distToParticleSqr = (x * x) + (y * y);
//    float distToParticleSqr = dot(regionCenterToParticle, regionCenterToParticle);
//    if (distToParticleSqr > uParticleRegionRadiusSqr)
//    {
//        return true;
//    }
//
//    return false;
//}

uniform float uDeltaTimeSec;

/*------------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uParticleBufferSize)
    {
        Particle pCopy = AllParticles[index];

        // only update active particles 
        if (pCopy._isActive == 0)
        {
            return;
        }

        // when the compute shader is summoned to update active particles, this counter will 
        // give a count of how many active particles exist
        atomicCounterIncrement(acActiveParticleCounter);

        //vec4 acceleration = pCopy._netForceThisFrame / pCopy._mass;
        //pCopy._vel += (acceleration * uDeltaTimeSec);
        pCopy._pos += (pCopy._vel * uDeltaTimeSec);

        // if it went out of bounds, turn it off
        vec4 regionCenterToParticle = AllParticles[index]._pos - uParticleRegionCenter;
        float distToParticleSqr = dot(regionCenterToParticle, regionCenterToParticle);
        if (distToParticleSqr > uParticleRegionRadiusSqr)
        {
            pCopy._isActive = 0;
        }

        // copy the particle back into global memory
        AllParticles[index] = pCopy;
    }
}

