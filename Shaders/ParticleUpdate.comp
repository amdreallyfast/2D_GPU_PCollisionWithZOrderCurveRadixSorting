// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// - PARALLEL_SORT_WORK_GROUP_SIZE_X
// REQUIRES SsboBufferBindings.comp
// REQUIRES UniformLocations.comp
// REQUIRES ParticleBuffer.comp

// Y and Z work group sizes default to 1
layout (local_size_x = PARTICLE_OPERATIONS_WORK_GROUP_SIZE_X) in;


// unlike SSBOs, atomic counter buffers seem to need a declaration like this and cannot be bound 
// dynamically as in ParticleSsbo and PolygonSsbo, so declare the atomic counters up front to 
// make it easier to keep the numbers straight.
// Note: Discovered by experience and through this: https://www.opengl.org/wiki/Atomic_Counter.
layout (binding = ACTIVE_PARTICLE_ATOMIC_COUNTER_BUFFER, offset = 0) uniform atomic_uint acActiveParticleCounter;


/*------------------------------------------------------------------------------------------------
Description:
    Checks if the provided particle has gone outside the circle that defines where particles are 
    "active".
Parameters:
    particleIndex   An index into the AllParticles array.
Returns:
    True if the particle is out of bounds and should be reset, otherwise false.
Creator:    John Cox (1-7-2016)
------------------------------------------------------------------------------------------------*/
layout(location = UNIFORM_LOCATION_PARTICLE_REGION_CENTER) uniform vec4 uParticleRegionCenter;
layout(location = UNIFORM_LOCATION_PARTICLE_REGION_RADIUS_SQR) uniform float uParticleRegionRadiusSqr;
bool ParticleOutOfBoundsPolygon(uint particleIndex)
{
    vec4 regionCenterToParticle = AllParticles[particleIndex]._pos - uParticleRegionCenter;

    //float x = regionCenterToParticle.x;
    //float y = regionCenterToParticle.y;
    //float distToParticleSqr = (x * x) + (y * y);
    float distToParticleSqr = dot(regionCenterToParticle, regionCenterToParticle);
    if (distToParticleSqr > uParticleRegionRadiusSqr)
    {
        return true;
    }

    return false;
}

layout(location = UNIFORM_LOCATION_DELTA_TIME_SEC) uniform float uDeltaTimeSec;

/*------------------------------------------------------------------------------------------------
Description:
    The compute shader's startup function.
Parameters: None
Returns:    None
Creator:    John Cox (9-25-2016)
------------------------------------------------------------------------------------------------*/
void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < uMaxParticles)
    {
        Particle p = AllParticles[index];

        // only update active particles 
        if (p._isActive == 0)
        {
            return;
        }

        // when the compute shader is summoned to update active particles, this counter will 
        // give a count of how many active particles exist
        atomicCounterIncrement(acActiveParticleCounter);

        vec4 acceleration = p._netForceThisFrame / p._mass;
        p._vel += (acceleration * uDeltaTimeSec);
        p._pos += (p._vel * uDeltaTimeSec);

        // if it went out of bounds, reset it
        if (ParticleOutOfBoundsPolygon(index))
        {
            p._isActive = 0;
        }                

        // regardless of whether it went out of bounds or not, reset the net force and collision 
        // count for this frame
        p._netForceThisFrame = vec4(0,0,0,0);
        p._collisionCountThisFrame = 0;

        // copy the updated one back into the array
        AllParticles[index] = p;
    }
}

